// Generated by kaoscript 0.9.1
var __ks__ = require("@kaoscript/runtime");
var Dictionary = __ks__.Dictionary, Type = __ks__.Type;
module.exports = function() {
	var metadata = require("../package.json");
	var Compiler = require("./compiler.js")().Compiler;
	var execSync = require("child_process").execSync;
	var program = require("commander");
	var Module = require("module");
	var path = require("path");
	var vm = require("vm");
	function rewire(option) {
		if(arguments.length < 1) {
			throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 1)");
		}
		if(option === void 0 || option === null) {
			throw new TypeError("'option' is not nullable");
		}
		var files = [];
		for(var __ks_0 = 0, __ks_1 = option.split(","), __ks_2 = __ks_1.length, item; __ks_0 < __ks_2; ++__ks_0) {
			item = __ks_1[__ks_0];
			item = item.split("=");
			files.push((function() {
				var d = new Dictionary();
				d.input = item[0];
				d.output = item[1];
				return d;
			})());
		}
		return files;
	}
	program.version(metadata.version).usage("[options] <file>").option("-k, --clean", "remove compiler's cache files").option("-c, --compile", "compile to JavaScript and save as .js files").option("    --no-header", "suppress the \"Generated by\" header").option("-m, --metadata", "write the metadata file").option("-o, --output <path>", "set the output directory for compiled JavaScript").option("-p, --print", "print out the compiled JavaScript").option("    --no-register", "suppress \"require(kaoscript/register)\"").option("-r, --rewire <src-path=gen-path,...>", "rewire the references to source files to generated files", rewire).option("-t, --target <engine>", "set the engine/runtime/browser to compile for").parse(process.argv);
	if(program.clean === true) {
		execSync("find -L " + process.cwd() + " -type f \\( -name \"*.ksb\" -o -name \"*.ksh\" -o -name \"*.ksm\" \\) -exec rm {} \\;");
		if(program.args.length === 0) {
			console.log("all clean!");
			process.exit(0);
		}
	}
	else if(program.args.length === 0) {
		program.outputHelp();
		process.exit(1);
	}
	var file = path.join(process.cwd(), program.args[0]);
	var options = (function() {
		var d = new Dictionary();
		d.header = program.header;
		d.register = program.register;
		return d;
	})();
	if(Type.isValue(program.rewire)) {
		options.rewire = [];
		for(var __ks_0 = 0, __ks_1 = program.rewire.length, item; __ks_0 < __ks_1; ++__ks_0) {
			item = program.rewire[__ks_0];
			options.rewire.push((function() {
				var d = new Dictionary();
				d.input = path.join(process.cwd(), item.input);
				d.output = path.join(process.cwd(), item.output);
				return d;
			})());
		}
	}
	if(Type.isValue(program.target)) {
		options.target = program.target;
	}
	if(program.compile === true) {
		options.output = path.join(process.cwd(), Type.isValue(program.output) ? program.output : "");
		var compiler = new Compiler(file, options);
		compiler.compile();
		if(program.print === true) {
			console.log(compiler.toSource());
		}
		compiler.writeOutput();
		if(program.metadata === true) {
			compiler.writeMetadata();
		}
	}
	else if(program.print === true) {
		var compiler = new Compiler(file, options);
		compiler.compile();
		console.log(compiler.toSource());
	}
	else {
		var compiler = new Compiler(file, options);
		compiler.compile();
		var sandbox = new Dictionary();
		var __ks_0;
		for(var key in global) {
			sandbox[key] = global[key];
		}
		sandbox.console = console;
		sandbox.__dirname = path.dirname(file);
		sandbox.__filename = file;
		var _module = sandbox.module = new Module("eval");
		var _require = sandbox.require = function(path) {
			if(arguments.length < 1) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(path === void 0 || path === null) {
				throw new TypeError("'path' is not nullable");
			}
			return Module._load(path, _module, true);
		};
		_module.filename = file;
		for(var __ks_0 = 0, __ks_1 = Object.getOwnPropertyNames(require), __ks_2 = __ks_1.length, r; __ks_0 < __ks_2; ++__ks_0) {
			r = __ks_1[__ks_0];
			if((r !== "paths") && (r !== "arguments") && (r !== "caller")) {
				_require[r] = require[r];
			}
		}
		_require.paths = _module.paths = Module._nodeModulePaths(process.cwd()).concat(process.cwd());
		_require.resolve = function(request) {
			if(arguments.length < 1) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(request === void 0 || request === null) {
				throw new TypeError("'request' is not nullable");
			}
			return Module._resolveFilename(request, _module);
		};
		vm.runInNewContext(compiler.toSource(), sandbox, file);
	}
};