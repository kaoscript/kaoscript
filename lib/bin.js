// Generated by kaoscript 0.11.0
const {Helper, OBJ, Type} = require("@kaoscript/runtime");
module.exports = function() {
	var metadata = require("../package.json");
	var Compiler = require("./compiler.js")().Compiler;
	var program = require("commander");
	var execSync = require("child_process").execSync;
	var Module = require("module");
	var path = require("path");
	var vm = require("vm");
	function rewire() {
		return rewire.__ks_rt(this, arguments);
	};
	rewire.__ks_0 = function(option, defaultValue) {
		if(defaultValue === void 0) {
			defaultValue = null;
		}
		const files = [];
		for(let __ks_2 = option.split(","), __ks_1 = 0, __ks_0 = __ks_2.length, item; __ks_1 < __ks_0; ++__ks_1) {
			item = __ks_2[__ks_1];
			const parts = item.split("=");
			files.push((() => {
				const o = new OBJ();
				o.input = parts[0];
				o.output = parts[1];
				return o;
			})());
		}
		return files;
	};
	rewire.__ks_rt = function(that, args) {
		const t0 = Type.isValue;
		if(args.length === 2) {
			if(t0(args[0])) {
				return rewire.__ks_0.call(that, args[0], args[1]);
			}
		}
		throw Helper.badArgs();
	};
	program.version(metadata.version).usage("[options] <file>").option("-k, --clean", "remove compiler's cache files").option("-c, --compile", "compile to JavaScript and save as .js files").option("    --no-header", "suppress the \"Generated by\" header").option("-m, --metadata", "write the metadata file").option("-o, --output <path>", "set the output directory for compiled JavaScript").option("-p, --print", "print out the compiled JavaScript").option("    --no-register", "suppress \"require(kaoscript/register)\"").option("-r, --rewire <src-path=gen-path,...>", "rewire the references to source files to generated files", rewire).option("-t, --target <engine>", "set the engine/runtime/browser to compile for").parse(process.argv);
	if(program.clean === true) {
		execSync(Helper.concatString("find -L ", process.cwd(), " -type f \\( -name \"*.ksb\" -o -name \"*.ksh\" -o -name \"*.ksr\" -o -name \"*.kse\" \\) -exec rm {} \\;"));
		if(program.args.length === 0) {
			console.log("all clean!");
			process.exit(0);
		}
	}
	else if(program.args.length === 0) {
		program.outputHelp();
		process.exit(1);
	}
	const file = path.join(process.cwd(), program.args[0]);
	const options = (() => {
		const o = new OBJ();
		o.header = program.header;
		o.register = program.register;
		return o;
	})();
	if(Type.isValue(program.rewire)) {
		options.rewire = [];
		for(let __ks_1 = 0, __ks_0 = program.rewire.length, item; __ks_1 < __ks_0; ++__ks_1) {
			item = program.rewire[__ks_1];
			options.rewire.push((() => {
				const o = new OBJ();
				o.input = path.join(process.cwd(), item.input);
				o.output = path.join(process.cwd(), item.output);
				return o;
			})());
		}
	}
	if(Type.isValue(program.target)) {
		options.target = program.target;
	}
	if(program.compile === true) {
		options.output = path.join(process.cwd(), Type.isValue(program.output) ? program.output : "");
		const compiler = new Compiler(file, options);
		compiler.__ks_func_compile_0();
		if(program.print === true) {
			console.log(compiler.__ks_func_toSource_0());
		}
		compiler.__ks_func_writeOutput_0();
	}
	else if(program.print === true) {
		const compiler = new Compiler(file, options);
		compiler.__ks_func_compile_0();
		console.log(compiler.__ks_func_toSource_0());
	}
	else {
		const compiler = new Compiler(file, options);
		compiler.__ks_func_compile_0();
		const sandbox = new OBJ();
		for(const key in global) {
			sandbox[key] = global[key];
		}
		sandbox.console = console;
		sandbox.__dirname = path.dirname(file);
		sandbox.__filename = file;
		const _module = sandbox.module = Helper.create(Module, [].concat(["eval"]));
		const _require = sandbox.require = Helper.function((path) => {
			return Module._load(path, _module, true);
		}, (that, fn, ...args) => {
			const t0 = Type.isValue;
			if(args.length === 1) {
				if(t0(args[0])) {
					return fn.call(null, args[0]);
				}
			}
			throw Helper.badArgs();
		});
		_module.filename = file;
		for(let __ks_2 = Object.getOwnPropertyNames(require), __ks_1 = 0, __ks_0 = __ks_2.length, r; __ks_1 < __ks_0; ++__ks_1) {
			r = __ks_2[__ks_1];
			if((r !== "paths") && (r !== "arguments") && (r !== "caller")) {
				_require[r] = require[r];
			}
		}
		_require.paths = _module.paths = Module._nodeModulePaths(process.cwd()).concat(process.cwd());
		_require.resolve = Helper.function((request) => {
			return Module._resolveFilename(request, _module);
		}, (that, fn, ...args) => {
			const t0 = Type.isValue;
			if(args.length === 1) {
				if(t0(args[0])) {
					return fn.call(null, args[0]);
				}
			}
			throw Helper.badArgs();
		});
		vm.runInNewContext(compiler.__ks_func_toSource_0(), sandbox, file);
	}
};